# shared memory for metrics
lua_shared_dict prometheus_metrics 10m;

# init phase for Prometheus client, dynamic server list, and timer-based metrics caching
init_worker_by_lua_block {
    local http = require "resty.http"    -- HTTP client library
    local cjson = require "cjson"         -- JSON parser

    -- Initialize Prometheus client
    prometheus = require("prometheus").init("prometheus_metrics")
    _NGINX_DOWNSTREAM_COUNTER = prometheus:counter("nginx_downstream_requests_total", "Total number of requests sent to downstream servers", {"downstream_server"})

    -- Initialize dynamic server list from template; each server includes address and port.
    servers = {
        {{ range service "api-server" }}
        { address = "{{ .Address }}", port = {{ .Port }} },
        {{ end }}
    }

    -- Global variables for caching weights and total weight
    cached_weights = {}
    cached_total_weight = 0

    -- Function to update metrics from Prometheus and calculate weights
    local function update_metrics(premature)
        if premature then
            return
        end

        local total_weight = 0
        local weights = {}
        local prometheus_url = "http://prometheus-server/api/v1/query"

        for i, server in ipairs(servers) do
            local instance = server.address .. ":" .. server.port

            -- Query for active_connections 
            local query_conn = 'active_connections{instance="' .. instance .. '"}'
            -- Query for average execution time over last 5 seconds
            local query_exec = 'rate(execution_time_seconds_sum[5s])/rate(execution_time_seconds_count[5s]){instance="' .. instance .. '"}'

            local httpc = http.new()

            -- Query active_connections
            local res_conn, err = httpc:request_uri(prometheus_url, {
                method = "GET",
                query = { query = query_conn },
                ssl_verify = false,
            })
            local conn_value = 1  -- Default value if no data
            if res_conn then
                local data_conn = cjson.decode(res_conn.body)
                if data_conn and data_conn.data and data_conn.data.result and data_conn.data.result[1] then
                    conn_value = tonumber(data_conn.data.result[1].value[2]) or 1
                end
            else
                ngx.log(ngx.ERR, "Query active_connections failed: ", err)
            end

            -- Query average execution time
            local res_exec, err = httpc:request_uri(prometheus_url, {
                method = "GET",
                query = { query = query_exec },
                ssl_verify = false,
            })
            local exec_value = 1  -- Default value if no data
            if res_exec then
                local data_exec = cjson.decode(res_exec.body)
                if data_exec and data_exec.data and data_exec.data.result and data_exec.data.result[1] then
                    exec_value = tonumber(data_exec.data.result[1].value[2]) or 1
                end
            else
                ngx.log(ngx.ERR, "Query average execution time failed: ", err)
            end

            -- Calculate effective load and weight
            local effective_load = conn_value * exec_value
            local weight = 1 / effective_load
            weights[i] = weight
            total_weight = total_weight + weight

            ngx.log(ngx.INFO, "Update Timer - Instance: ", instance,
                " active_connections: ", conn_value, " avg_exec_time: ", exec_value, " weight: ", weight)
        end

        -- Update global cache variables
        cached_weights = weights
        cached_total_weight = total_weight
    end

    -- Schedule a recurring timer to update metrics every 5 seconds
    local ok, err = ngx.timer.every(5, update_metrics)
    if not ok then
        ngx.log(ngx.ERR, "failed to create timer: ", err)
    end
}

log_format upstreamlog '$remote_addr $remote_user [$time_local] $request status:$status bytes:$body_bytes_sent upstream:$upstream_addr';

# Define a dummy upstream; actual upstream will be chosen dynamically.
upstream dummy_upstream {
    server 127.0.0.1:65535;
}

server {
    listen 80;
    server_name _;

    location /metrics {
        content_by_lua_block {
            prometheus:collect()
        }
    }

    location / {
        # Use dummy upstream; real upstream is selected in balancer_by_lua_block.
        proxy_pass http://dummy_upstream;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        access_log /var/log/nginx/access.log upstreamlog;

        balancer_by_lua_block {
            -- Use cached metrics for upstream selection
            if not cached_weights or cached_total_weight == 0 then
                ngx.log(ngx.ERR, "Cached metrics not available, fallback to first server")
                local chosen = servers[1]
                local balancer = require "ngx.balancer"
                local ok, err = balancer.set_current_peer(chosen.address, chosen.port)
                if not ok then
                    ngx.log(ngx.ERR, "failed to set current peer: ", err)
                    return ngx.exit(500)
                end
                return
            end

            -- Weighted random selection using cached weights
            local rand = math.random() * cached_total_weight
            local selected_index = 1
            for i, weight in ipairs(cached_weights) do
                rand = rand - weight
                if rand <= 0 then
                    selected_index = i
                    break
                end
            end

            local chosen = servers[selected_index]
            ngx.log(ngx.INFO, "Selected upstream server: " .. chosen.address .. ":" .. chosen.port)

            local balancer = require "ngx.balancer"
            local ok, err = balancer.set_current_peer(chosen.address, chosen.port)
            if not ok then
                ngx.log(ngx.ERR, "failed to set current peer: ", err)
                return ngx.exit(500)
            end
        }
    }

    # log phase: record the metric after response for the /factorize endpoint
    log_by_lua_block {
        if ngx.var.uri == "/factorize" then
            local downstream = ngx.var.upstream_addr or "unknown"
            _NGINX_DOWNSTREAM_COUNTER:inc(1, {downstream})
        end
    }
}
