
log_format  upstreamlog  '$remote_addr $remote_user [$time_local] '
                         '$request status:$status bytes:$body_bytes_sent '
                         'upstream:$upstream_addr';

# Shared dict for storing metrics (e.g., last 5-second average times)
lua_shared_dict metrics_store 10m;
# Resolver definition with custom cache
resolver 127.0.0.11 valid=30s ipv6=off;


# init_worker_by_lua_block to initialize the shared dict
init_worker_by_lua_block {
    local http = require "resty.http"
    local cjson = require "cjson"
    local metrics_dict = ngx.shared.metrics_store

    local function fetch_and_store_metrics(premature)
        if premature then
            return
        end

        local httpc = http.new()
        local res, err = httpc:request_uri("http://prometheus:9090/api/v1/query", {
            method = "GET",
            query = {
                query = "rate(execution_time_seconds_sum{job=\"api-server\"}[5s]) / rate(execution_time_seconds_count{job=\"api-server\"}[5s])"
            },
            timeout = 2000, -- 1s
        })
        if not res or res.status ~= 200 then
            ngx.log(ngx.ERR, "Failed to fetch metrics from Prometheus: ", err) 
            return
        end
        -- 解析返回的 JSON
        local data = cjson.decode(res.body)
        if not data or not data.data or not data.data.result then
            ngx.log(ngx.ERR, "Invalid data from Prometheus: ", res.body)
            return
        end

        -- 遍历返回结果，把每个 instance 的值存到共享字典
        for _, item in ipairs(data.data.result) do
           
            local instance = item.metric.instance
            local val_str = item.value and item.value[2]

            if instance and val_str then
                local val_num = tonumber(val_str)
                if val_num then
                    metrics_dict:set(instance .. ":execution_time", val_num)
                    ngx.log(ngx.INFO, "Set ", instance, ":execution_time = ", val_num)
                end
            end
        end
    end

    -- 每 5 秒执行一次
    local ok, err = ngx.timer.every(5, fetch_and_store_metrics)
    if not ok then
        ngx.log(ngx.ERR, "failed to create timer: ", err)
    end
}


# Upstream definition with custom balancer_by_lua_block
upstream factorization_servers {
    server api-server1:8080;
    server api-server2:8080; 

    balancer_by_lua_block {
        local balancer = require("ngx.balancer")
        local metrics_dict = ngx.shared.metrics_store

        local function get_execution_time(instance)
            local val = metrics_dict:get(instance .. ":execution_time")
            if not val then
                return 0
            end
            return val
        end

        -- 后端列表
        local backends = {
            "172.26.0.5:8080",
            "172.26.0.3:8080"
        }

        -- 先选出合适的 chosen_instance
        local chosen_instance 
        local min_time = math.huge

        for _, instance in ipairs(backends) do
            local exec_time = get_execution_time(instance)
            
            -- 简单逻辑：选平均执行时间最小的后端
            if exec_time < min_time then
                min_time = exec_time
                chosen_instance = instance
            end
        end


        if not chosen_instance then
            ngx.log(ngx.ERR, "No available backend instance")
            return ngx.exit(503)
        end

        -- 确保此时 chosen_instance 已经有值
        local host, port = chosen_instance:match("([^:]+):(%d+)")
        if not host or not port then
            ngx.log(ngx.ERR, "Invalid chosen instance format: ", chosen_instance)
            return ngx.exit(500)
        end

        -- ngx.log(ngx.ERR, "chosen_instance=", chosen_instance)
        -- ngx.log(ngx.ERR, "host=", host, ", port=", port)

        -- 最后再设置 peer
        -- local ok, err = balancer.set_current_peer("172.26.0.5", 8080)

        local ok, err = balancer.set_current_peer(host, tonumber(port))
        if not ok then
            ngx.log(ngx.ERR, "Failed to set backend peer: ", err)
            return ngx.exit(500)
        end
    }
}

# Server block listening on port 80
server {
    listen 80;
    server_name _;

    # Example location to proxy requests
    location / {
        proxy_pass http://factorization_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

        # Access log with custom format (optional)
        access_log /var/log/nginx/access.log upstreamlog;
    }
}
